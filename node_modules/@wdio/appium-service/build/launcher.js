"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@wdio/logger"));
const config_1 = require("@wdio/config");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const util_1 = require("util");
const utils_1 = require("./utils");
const log = logger_1.default('@wdio/appium-service');
const DEFAULT_LOG_FILENAME = 'wdio-appium.log';
const DEFAULT_CONNECTION = {
    protocol: 'http',
    hostname: 'localhost',
    port: 4723,
    path: '/'
};
class AppiumLauncher {
    constructor(options, capabilities, config) {
        this.options = options;
        this.capabilities = capabilities;
        this.args = {
            basePath: '/',
            ...(options.args || {})
        };
        this.logPath = options.logPath || config.outputDir;
        this.command = options.command;
        this.appiumArgs = [];
        if (!this.command) {
            this.command = 'node';
            this.appiumArgs.push(utils_1.getAppiumCommand());
        }
    }
    async onPrepare() {
        const isWindows = process.platform === 'win32';
        this.appiumArgs.push(...utils_1.cliArgsFromKeyValue(this.args));
        if (isWindows) {
            this.appiumArgs.unshift('/c', this.command);
            this.command = 'cmd';
        }
        (Array.isArray(this.capabilities)
            ? this.capabilities
            : Object.values(this.capabilities)).forEach((cap) => !config_1.isCloudCapability(cap.capabilities) && Object.assign(cap, DEFAULT_CONNECTION, this.args.port ? { port: this.args.port } : {}, { path: this.args.basePath }, { ...cap }));
        this.process = await util_1.promisify(this._startAppium)(this.command, this.appiumArgs);
        if (typeof this.logPath === 'string') {
            this._redirectLogStream(this.logPath);
        }
    }
    onComplete() {
        if (this.process) {
            log.debug(`Appium (pid: ${process.pid}) killed`);
            this.process.kill();
        }
    }
    _startAppium(command, args, callback) {
        log.debug(`Will spawn Appium process: ${command} ${args.join(' ')}`);
        let process = child_process_1.spawn(command, args, { stdio: ['ignore', 'pipe', 'pipe'] });
        let error;
        process.stdout.on('data', (data) => {
            if (data.includes('Appium REST http interface listener started')) {
                log.debug(`Appium started with ID: ${process.pid}`);
                callback(null, process);
            }
        });
        process.stderr.once('data', err => { error = err; });
        process.once('exit', (exitCode) => {
            let errorMessage = `Appium exited before timeout (exit code: ${exitCode})`;
            if (exitCode == 2) {
                errorMessage += '\n' + (error || 'Check that you don\'t already have a running Appium service.');
                log.error(errorMessage);
            }
            callback(new Error(errorMessage), null);
        });
    }
    _redirectLogStream(logPath) {
        const logFile = utils_1.getFilePath(logPath, DEFAULT_LOG_FILENAME);
        fs_extra_1.ensureFileSync(logFile);
        log.debug(`Appium logs written to: ${logFile}`);
        const logStream = fs_extra_1.createWriteStream(logFile, { flags: 'w' });
        this.process.stdout.pipe(logStream);
        this.process.stderr.pipe(logStream);
    }
}
exports.default = AppiumLauncher;
